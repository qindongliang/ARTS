
 [Algorithm 922. Sort Array By Parity II](#algorithm)

 [Review](#review)

 [Technique Spring Boot如何集成Nginx配置代理 ](#technique)

 [Share](#share)


# Algorithm
 https://leetcode.com/problems/find-common-characters/
 
 ```java
package leetcode.easy.array_all;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/***
 * https://leetcode.com/problems/find-common-characters/
 * 给定一个全英文字母小写的字符串数组
 * 统计出里面最小的公共字符的个数，最后输出到一个List<String>里面
 * 举例
 * [aooo, aoo, boo] , 输出是oo，注意oo需要拆分成2个字符放入List<String>里面
 */
public class FindCommonsCharacters {


    public static List<String> commonChars(String[] A) {

        List<String> ans=new ArrayList<>();
        //声明数组，用来保存最终的公共字符的个数
        int count[]=new int[26];
        //初始化填充最大值，便于统一处理
        Arrays.fill(count,Integer.MAX_VALUE);

        for (String str:A){

            // 对每一个字符串声明一个字符数组
            int[] cnt=new int[26];
            //统计在这一个字符串里面，每个字符出现的字数
            for(char c:str.toCharArray()){
                cnt[c-'a']++;
            }

            //拿当前字符串的数组统计值，与count数组里面的统计值进行比较，取最小值就是公共字符（木桶短板决定）
            //注意，如果第一个字符串里面出现某个字符，第二个字符串里面没有出现，那么取最小值就是没有出现，这一点需要注意
            for (int i = 0; i < 26; i++) {
                count[i]=Math.min(count[i],cnt[i]);
            }

        }

        //依次循环处理完所有的字符串后，进行遍历输出组装，就是所有的公共字符
        for(char c='a';c<='z';c++){
            while (count[c-'a']-->0){
                ans.add(c+"");
            }

        }

        return ans;
    }


    public static void main(String[] args) {

        System.out.println(commonChars(new String[]{"bella","label","roller"}));

    }



}

```

# Review


# Technique

```java

配置Nginx统一代理web容器如tomcat，jetty的请求，在日常开发中很常见，那么在配置集成的时候应该注意些什么呢?


下面我们将通过一个例子介绍如何和Nginx配置：

首先，我们先看下一个spring boot项目的结构：

```
demo
   src
       main
           assemble
                 package.xml
           filters
                 dev.properties
                 test.properties
                 pro.properties
           java
              dao
              service
              controller
           resources
              static
                    js
                    css
                    img
              templates
                    index.vm
                    error.vm
              application.properties
              logback.xml
              
       test       
   target
   logs
   pom.xml
   README.md
```

注意上面的是传统的spring boot的标准web格式，这里面包含了前端的页面也在这个项目里面，不是所谓的大前端的严格的前后端分离模式。如果集成了配置管理中心比如携程的阿波罗就可以再精简一点，这个不再细说，感兴趣的朋友可自行去研究一下。


在spring boot里面，默认的静态的资源文件是放在resources目录下一个static的目录下，如果现在在static目录有一个xxx.css文件，那么可以直接使用下面的方式进行访问：

```
http://localhost:8888/xxx.css
```

同理js，img，各种静态资源都一样。上面的方式是比较直接，但比较乱，因为在端口号后面的没有再分区路径。


现在看下我们的controller类：

```
@Controller
@RequestMapping("/c1")
public class DemoController {

    @RequestMapping("/m1")
    public String m1(Map<String, Object> model, HttpServletResponse response, HttpServletRequest request) {
        return "index";//返回到templates下面的index.vm模板
    }
    
    @RequestMapping("/m2")
    public String m2(Map<String, Object> model, HttpServletResponse response, HttpServletRequest request) {
        return "error";//返回到templates下面的error.vm模板
    }
    
}
```

在运维层面，一般只会为一个微服务项目配置一个域名映射，所以为了方便nginx统一代理映射，我们需要一个一级路径来做nginx的代理转发路径，故在上面的DemoController类里面，在类的注解上加上了一级路径，你也可以在方法级别添加比如直接写
```
/c1/m1
/c1/m2
```
效果是一样的。

下面我们看下nginx的配置：

```
  location ^~ /c1/ {
    access_log  /data/logs/nginx/c1.log  main;
    proxy_set_header   X-Real-IP        $remote_addr;
    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
    proxy_set_header Host $host;
    proxy_pass http://c1;
  }
  
upstream question-recognition {
 server 192.168.10.125:8888 max_fails=3;
}
  
```

在上面的nginx配置中，我们配置了c1作为demo项目访问的一级路径，也就是说任何访问请求，都必须在c1的路径下，否则就可能出现问题，比如此时我访问：
```
http://192.168.10.125:8888/c1/m1
```
那么将会转发到index.vm页面，但此时注意，如果index.vm页面里面如下引用了xxx.js文件，那么将会失效：

```js
<script src="xxx.js" > </script>
```

上面的js文件，在html页面在浏览器加载的时候，会发送请求：
```
http://192.168.10.125:8888/xxx.js
```

注意了，如果没有配置nginx代理这一层，上面的这个请求是没问题的，但配置了nginx拦截，必须只能是c1路径下的请求才会放行，所以我们需要在static目录下同样新建一个c1目录，然后把xxx.js文件拷贝到该目录下即可，如下：

```
static
    c1
      xxx.js

```

然后在velocity的模板文件里面，引入js路径改为：

```
<script src="/c1/xxx.js" > </script>
```
上面的js文件，在html加载的时候，会发送请求：
```
http://192.168.10.125:8888/c1/xxx.js
```
由于其一级路径是c1，所以通过了nginx的拦截，整个页面就加载正常，这样以来与Nginx的集成就算成功了，这一点也是要在开发中注意的，通过了细化路径，也方便了访问权限的拦截控制。

```



# Share





