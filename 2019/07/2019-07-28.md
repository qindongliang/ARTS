
 [Algorithm CanPlaceFlowers ](#algorithm)

 [Review](#review)

 [Technique Java基本类型的内存分配在栈还是堆？](#technique)

 [Share](#share)


# Algorithm

```java
package leetcode.easy.array_all;

/****
 * https://leetcode.com/problems/can-place-flowers/
 *
 * 给定一个int数组，代表花罐子，里面的数值只能是0或者1，0代表空，1代表有花
 * 只有两个0之间才能种花，如果两个1挨着，会导致他们争夺水资源导致死亡。
 * 现在给定一个花罐数组，并给出新种的花的个数，让求出，这个罐子中能不能放的下新增的花。
 *
 * 思路：
 *
 * 循环数组，初始化情况下count=1，然后对连续0计数，如果遇到非0，就count-1的结果除以2，就是能中的颗数，
 * 直到循环结束，最后在除以2，看商是否大于等于n，如果满足，则可以中下。
 */
public class CanPlaceFlowers {
    public static boolean canPlaceFlowers(int[] flowerbed, int n) {

        int count = 1;
        int result = 0;
        for(int i=0; i<flowerbed.length; i++) {
            if(flowerbed[i] == 0) {
                count++;
            }else {
                result += (count-1)/2;
                count = 0;
            }
        }
        if(count != 0) result += count/2;
        return result>=n;
    }
    public static void main(String[] args) {
        int arr[]={0,0};
        System.out.println(canPlaceFlowers(arr,1));
    }
}

```

# Review


# Technique

![image](https://1.bp.blogspot.com/-gKWUcwIKWWU/VvPtKUAIFjI/AAAAAAAAFRc/WLCqWfSxlZ4ioocmBuFS3KaRhzs0I13OA/s640/Difference%2Bbetween%2Bstack%2Band%2Bheap%2Bmemory%2Bin%2BJava.gif)

我们都知道在Java里面new出来的对象都是在堆上分配空间存储的，但是针对基本类型却有所区别，基本类型可以分配在栈上，也可以分配在堆上，这是为什么？

在这之前，我们先看下Java的基本类型8种分别是：

```
byte =>8bit
short => 16bit
int => 32bit
long =>64bit

folat => 单精度32位
double => 双精度64位

boolean => 注意oracle官网文档介绍，boolean代表1bit的信息，但它本身的size却不是精确的，依赖于jvm和os的实现，比较常见的说法是，boolean单独使用的时候，在编译时是使用int代替的，如果是boobean数组，则是使用1byte代替

char => 16bit

```
注意字符串内部是用char数组实现的，所以属于引用类型。


基本类型在成员变量和局部（local）变量的时候其内存分配机制是不一样的。

如果是成员变量，那么不分基本类型和引用类型都是在java的堆内存里面分配空间，而局部变量的基本类型是在栈上分配的。栈属于线程私有的空间，局部变量的生命周期和作用域一般都很短，为了提高gc效率，所以没必要放在堆里面。

如下代码：

```
public class DemoTest {

    int y;// 分布在堆上
    public static void main(String[] args) {

        int x=1; //分配在栈上
        String name=new String("cat");//数据在堆上，name变量的指针在栈上
        String address="北京";//数据在常量池，属于堆空间，指针在栈
        Integer price=4;//包装类型同样是引用类型，编译时会自动装拆相，所以数据在堆上，指针在栈
    }


}
```

在java里面通过new出来的对象都在堆上分配，这里有两种特殊情况，

（1）字符串的字面量

字符串的字面量，没有new关键字，但却是在堆上分配内存的，严格的说是在堆里面的字符串常量池里面。

（2）基本类型的包装类

同样的道理，针对各个基本类型的包装类型，如：Integer，Double，Long等，这些属于引用类型，我们直接在局部方法里面使用包装类型赋值，那么数据真正的内存分配还是在堆内存里面，这里有个隐式的拆装箱来自动完成转换，数据的指针是在栈上，包装类型的出现主要是为了基本类型能够用在泛型的设计上和使用null值，而基本类型则拥有更好的计算性能，这一点我们也需要注意。






# Share





